{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PiLisp","text":"<p>PiLisp\u2014An interpreted Lisp inspired by Clojure, implemented in Dart.</p> <p>The language implemented in pilisp-core runs on all targets that Dart supports.</p>"},{"location":"#appetizer","title":"Appetizer","text":"<pre><code>(println \"Hello world!\")\n;; (STDOUT) \"Hello world!\\n\"\n;;=&gt; nil\n(reduce + (range 5))\n;;=&gt; 10\n(pl&gt; bindings | keys | sort | drop 900 | take 10)\n;;=&gt;\n;; [\n;;   stringify-keys\n;;   subs\n;;   substring\n;;   swap!\n;;   symbol\n;;   symbol?\n;;   take\n;;   take-while\n;;   tenth\n;;   term\n;; ]\n(dart/int.tryParse \"1234567891234567891\")\n;;=&gt; 1234567891234567891\n(dart/int.tryParse \"12345678912345678912\")\n;;=&gt; nil\n(dart/BigInt.tryParse \"123456789123456789123456789\")\n;;=&gt; 123456789123456789123456789\n(count (apropos-full \"dart/\"))\n;;=&gt; 613\n(map str/upper-case [\"no\" \"lazy\" \"seqs\"])\n;;=&gt;\n;; [\n;;   \"NO\"\n;;   \"LAZY\"\n;;   \"SEQS\"\n;; ]\n</code></pre> <p>Peruse the Tour for a more detailed walk-through.</p>"},{"location":"#how-to-learn","title":"How to Learn","text":"<p>Check out:</p> <ul> <li>Installation</li> <li>REPL Usage</li> <li>CLI Commands</li> </ul>"},{"location":"#motivation","title":"Motivation","text":"<p>PiLisp is written in Dart to allow for (1) leveraging Dart libraries while (2) running on all the targets that the Dart platform supports, but especially being able to (3) compile programs to standalone native executables.</p> <p>PiLisp is a Lisp modeled after Clojure, because I've used Clojure for years and find it to be an elegant instrument of thought and computation.</p> <p>In 2022, I wrote a program to interact with Shortcut's REST API from the CLI called sc and cursed it with an intentionally crippled Lisp implementation. The hallmark that Lisp's design was making parentheses optional for top-level invocation and supporting the pipe <code>|</code> character as an infix thread-first operator.</p> <p>PiLisp is a shortened form of \"Piped Lisp,\" because I set out to reimplement that underpowered Lisp with a proper approach, knowing that I could support its piping/expression-threading behavior via a macro, rather than by hard-coding it into the language implementation. As projects tend to do, PiLisp morphed from being a language that I intended to re-embed into the sc project into an independent language with interesting features in its own right. It became so far removed from the original project that it was not longer straightforward to drop it in as a replacement.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#executables","title":"Executables","text":"<p>Download a standalone executable for your platform from GitHub:</p> <p>PiLisp GitHub Releases</p> <p>macOS Users</p> <p>These executables are not signed. On macOS depending on your security settings, you may need to make an exception for the executable to be able to run. One can accomplish this in a coarse way by running the following commands at the shell:</p> <pre><code>sudo spctl --global-disable\n./pl --help\nsudo spctl --global-enable\n</code></pre>"},{"location":"install/#editor-integration","title":"Editor Integration","text":"<p>The only supported editor at this point is Emacs. See these repositories:</p> <ul> <li>pilisp/emacs-pilisp-mode for an Emacs mode derived from <code>clojure-mode</code></li> <li>pilisp/emacs-inf-pilisp to use PiLisp with Emacs' inferior lisp mode, derived from <code>inf-clojure</code></li> </ul>"},{"location":"install/#dart-library","title":"Dart Library","text":"<p>Locally, you can read the README.md file for each package in the <code>pkgs</code> folder in this repository.</p> <p>On pub.dev, you can find installation instructions (and more) for all packages released by the official pilisp.dev publisher:</p> <p>Official PiLisp Packages on pub.dev</p>"},{"location":"tour/","title":"Language Tour","text":"<p>Play Along</p> <p>If you'd like, start up a PiLisp REPL and evaluate expressions as we go.</p> <p>PiLisp supports a large subset of Clojure's syntax. Clojure is a Lisp, but with fewer parentheses than most, because Rich Hickey took advantage of other delimiters like square brackets and curly braces.</p> <pre><code>1    ; number\n1.1  ; also number, but it floats!\n\"a\"  ; string\n:a   ; PiLisp calls these \"terms\" rather than \"keywords\"\n.a   ; A term can be written using a dot. Dot or colon, makes no difference.\n()   ; A persistent list\n[]   ; A persistent vector\n{}   ; A persistent hash map\n#{}  ; A persistent set\n</code></pre> <p>Before we go any further, we need to get off the tour bus and talk about the <code>pl&gt;</code> macro.</p>"},{"location":"tour/#the-pl-macro","title":"The <code>pl&gt;</code> macro","text":"<p>When you start the PiLisp REPL, you're presented with the prompt <code>pl&gt;</code>. This is actually a hint that the REPL is calling PiLisp's <code>pl&gt;</code> macro with your code as its arguments.</p> <p>The <code>pl&gt;</code> macro makes PiLisp a little less \"Lispy\". It makes top-level parentheses optional, and tries to invoke what you pass it, rather than simply evaluating it.</p> <p>Compare the following Clojure and PiLisp programs to gain a better understanding:</p> <p>Clojure</p> <pre><code>user&gt; rand-int\n#object[clojure.core$rand_int 0x2a551a63 \"clojure.core$rand_int@2a551a63\"]\n</code></pre> <p>PiLisp</p> <pre><code>pl&gt; rand-int 100\n42\npl&gt; rand-int 100\n73\n</code></pre> <p>Now we can get back to the language tour.</p>"},{"location":"tour/#functions","title":"Functions","text":"<p>PiLisp is a functional Lisp. For one, this means it treats functions as values.</p> <p>A lot of things are invocable in PiLisp.</p>"},{"location":"tour/#global-functions","title":"Global Functions","text":"<p>Since PiLisp does not provide namespaces or any kind of module facility, all functions that are bound to names in the environment are global.</p> <p>You can define a global function using the <code>def</code> special form or <code>defn</code> macro:</p> <pre><code>(defn point [x y] {.x x .y y})\n</code></pre> <p>You can invoke the function either with parentheses or, if you're at the REPL or using the <code>pl&gt;</code> by hand, without parentheses:</p> <pre><code>(point 2 3)\n;;=&gt;\n;; {\n;;   :x 2,\n;;   :y 3,\n;; }\n;; At REPL\npl&gt; point 2 3\n;;=&gt;\n;; {\n;;   :x 2,\n;;   :y 3,\n;; }\n</code></pre> <p>Notice two additional things:</p> <ol> <li>Commas are whitespace. We didn't have to use them when defining <code>point</code>.</li> <li>Terms can be written with either a leading colon or dot, but they're always printed with the colon.</li> </ol> <p>Evaluate <code>(bindings)</code> to see all of the bindings in the current PiLisp environment. You can further refine this to functions:</p> <pre><code>(defn fn-binding? [binding-entry]\n(let [[symbol binding] binding-entry]\n(fn? (:value binding))))\n;;=&gt; #&lt;function: fn-binding?&gt;\n(count (filter fn-binding? (bindings)))\n;;=&gt; 878\n</code></pre> <p>Functions, however, aren't the only invocable data types.</p>"},{"location":"tour/#invocable-data-types","title":"Invocable Data Types","text":"<p>Terms and strings will look themselves up in associative collections:</p> <pre><code>pl&gt; (.a {.a \"alpha\" .b \"beta\"})\n\"alpha\"\npl&gt; (\"name\" {\"name\" \"PiLisp\" \"host\" \"Dart\"})\n\"PiLisp\"\n</code></pre> <p>Collections are functions: vectors of their indices, maps of their keys, sets of their members:</p> <pre><code>([.a .b .c .d] 2)\n;;=&gt; :c\n({.alpha \"a\" .beta \"b\"} .beta)\n;;=&gt; \"b\"\n(#{\"I\" \"you\" \"we\" \"y'all\"} \"y'all\")\n;;=&gt; \"y'all\"\n</code></pre>"},{"location":"for-clojure-devs/comparison/","title":"Comparison of PiLisp and Clojure","text":"<p>PiLisp is interpreted. Clojure is compiled.</p> <p>PiLisp has been designed for use in smaller programs and systems.</p> <p>PiLisp does not implement namespaces. As a convention, PiLisp uses a slash to denote conceptual namespaces, e.g., <code>str/join</code> or <code>set/intersection</code>.</p> <p>PiLisp's immutable data structures are backed by the fast_immutable_collections library, not Clojure's implementations.</p> <p>The Dart VM does not support multiple threads of execution. For this reason, PiLisp does not have any of Clojure's concurrency features. The <code>atom</code> in PiLisp is equivalent to a Clojure <code>volatile</code>.</p> <p>The dart:mirrors library can only be used when running Dart programs via the Dart VM. For this reason, the core PiLisp language does not integrate it, and thus cannot provide ad hoc Dart reflection. The core PiLisp implementation does, however, generate PiLisp stubs for many Dart Core classes and methods. Evaluate <code>(apropos-full \"dart/\")</code> or review the generated Dart code to see what is available.</p> <p>PiLisp calls keywords terms and supports writing them either with a leading colon or a leading dot, i.e. <code>.a</code> is equivalent to <code>:a</code>. Terms are printed in the colon form.</p> <p>Destructuring is a powerful tool of thought. PiLisp supports destructuring in <code>let</code> bindings. By design, it does not support them in function signatures.</p> <p>PiLisp metadata is supported only on top-level bindings. Use <code>bindings</code> to get a map of symbols to maps of metadata and the bound value.</p>"},{"location":"usage/embedded/","title":"Embedding PiLisp","text":""}]}